"""
#!Implement GreedyMotifSearch with Pseudocounts

    * GreedyMotifSearch(Dna, k, t)
    *     form a set of k-mers BestMotifs by selecting 1st k-mers in each string from Dna
    *     for each k-mer Motif in the first string from Dna
    *         Motif1 ← Motif
    *         for i = 2 to t
    *             apply Laplace's Rule of Succession to form Profile from motifs Motif1, …, Motifi-1
    *             Motifi ← Profile-most probable k-mer in the i-th string in Dna
    *         Motifs ← (Motif1, …, Motift)
    *         if Score(Motifs) < Score(BestMotifs)
    *             BestMotifs ← Motifs
    *     output BestMotifs

* Given: Integers k and t, followed by a collection of strings Dna.
* Return: A collection of strings BestMotifs resulting from running GreedyMotifSearch(Dna, k, t) with pseudocounts. 
*         If at any step you find more than one Profile-most probable k-mer in a given string, use the one occurring first.
"""

import numpy as np
import os


def hamming(str1: str, str2: str):
    """
    Hamming Distance Problem: Compute the Hamming distance between two strings.

    Input: Two strings of equal length.
    Output: The Hamming distance between these strings.

    """
    assert len(str1) == len(str2)
    n = len(str1)
    res = 0
    for i in range(0, n):
        res += str1[i] != str2[i]
    return res


def distance_to_text(pattern: str, text: list):
    """
    Computes distance to text, where text is given as a collection of strings
    """
    res = 0
    for string in text:
        min_ham = np.infty
        for i in range(0, len(string)-len(pattern)+1):
            ham = hamming(pattern, string[i:i+len(pattern)])
            if ham < min_ham:
                min_ham = ham
        res += min_ham

    return res


def compute_prob(pattern: str, profile: np.array):
    """
    Compute probability that profile generates pattern
    """
    res = 1
    letter_indices = {
        "A": 0,
        "C": 1,
        "G": 2,
        "T": 3
    }
    for index, letter in enumerate(pattern):
        res *= profile[letter_indices[letter], index]

    return res


def most_probable(text: str, k: int, profile: np.array):
    """
    Profile-most probable k-mer in Text -- a k-mer that was most likely
    to have been generated by Profile among all k-mers in Text.

    Input: A string Text, an integer k, and a 4 × k matrix Profile.
    Output: A Profile-most probable k-mer in Text.
    """
    highest_prob = 0
    res = text[0:0+k]
    for i in range(0, len(text) - k + 1):
        pattern = text[i:i+k]
        prob = compute_prob(pattern, profile)
        if prob > highest_prob:
            highest_prob = prob
            res = pattern

    return res


def generate_profile(Dna: np.array):
    """
    Generate profile from given sequence of strings
    """
    letter_indices = {
        "A": 0,
        "C": 1,
        "G": 2,
        "T": 3
    }
    res = np.zeros((4, len(Dna[0])))
    for i in range(len(Dna)):
        for j in range(len(Dna[0])):
            res[letter_indices[Dna[i][j]], j] += 1
    res = res + np.ones_like(res)
    return np.divide(res, np.sum(res, axis=0))


def compute_consensus(profile: np.array):
    """
    Compute consensus for given profile
    """
    letter_indices = {
        0: "A",
        1: "C",
        2: "G",
        3: "T"
    }
    return "".join([letter_indices[j] for j in np.argmax(profile, axis=0)])


def greedy_motif_search_with_pseudocounts(Dna: list, k: int, t: int):
    """
    GreedyMotifSearch(Dna, k, t)
        BestMotifs ← motif matrix formed by first k-mers in each string from Dna
        for each k-mer Motif in the first string from Dna
            Motif1 ← Motif
            for i = 2 to t
                apply Laplace's Rule of Succession to form Profile from motifs Motif1, …, Motifi-1
                Motifi ← Profile-most probable k-mer in the i-th string in Dna
            Motifs ← (Motif1, …, Motift)
            if Score(Motifs) < Score(BestMotifs)
                BestMotifs ← Motifs
        return BestMotifs

    Input: Integers k and t, followed by a space-separated collection of strings Dna.
    Output: A collection of strings BestMotifs resulting from applying GreedyMotifSearch(Dna, k, t).
    """
    BestMotifs = [string[0:k]for string in Dna]
    profile_best = generate_profile(BestMotifs)
    consensus_best = compute_consensus(profile_best)
    score_best = distance_to_text(consensus_best, BestMotifs)
    for i in range(0, len(Dna[0]) - k + 1):
        Motifs = [None]*t
        Motifs[0] = Dna[0][i: i+k]
        for j in range(1, t):
            profile = generate_profile(Motifs[:j])
            Motifs[j] = most_probable(Dna[j], k, profile)
        consensus = compute_consensus(profile)
        score = distance_to_text(consensus, Motifs)
        if score < score_best:
            BestMotifs = Motifs
            consensus_best = consensus
            score_best = score
            profile_best = profile
    return BestMotifs


if __name__ == '__main__':
    with open("/home/snopoff/Downloads/rosalind_ba2e.txt", "r") as f:
        lines = f.readlines()
    strings = [line.strip() for line in lines]
    k, t = list(map(int, strings[0].split(" ")))

    Dna = strings[1:]

    res = greedy_motif_search_with_pseudocounts(Dna, k, t)
    res = " ".join(res)
    with open(os.getcwd() + "/res.txt", "w") as f:
        f.write("".join(list(map(str, res))))
