"""
#!Implement GibbsSampler

    * GIBBSSAMPLER(Dna, k, t, N)
    *     randomly select k-mers Motifs = (Motif1, …, Motift) in each string
    *         from Dna
    *     BestMotifs ← Motifs
    *     for j ← 1 to N
    *         i ← Random(t)
    *         Profile ← profile matrix constructed from all strings in Motifs
    *                    except for Motifi
    *         Motifi ← Profile-randomly generated k-mer in the i-th sequence
    *         if Score(Motifs) < Score(BestMotifs)
    *             BestMotifs ← Motifs
    *     return BestMotifs

* Given: Integers k, t, and N, followed by a collection of strings Dna.
* Return: The strings BestMotifs resulting from running GibbsSampler(Dna, k, t, N) with 20 random starts. 
*         Remember to use pseudocounts!
"""
import numpy as np
import os


def hamming(str1: str, str2: str):
    """
    Hamming Distance Problem: Compute the Hamming distance between two strings.

    Input: Two strings of equal length.
    Output: The Hamming distance between these strings.

    """
    assert len(str1) == len(str2)
    n = len(str1)
    res = 0
    for i in range(0, n):
        res += str1[i] != str2[i]
    return res


def distance_to_text(pattern: str, text: list):
    """
    Computes distance to text, where text is given as a collection of strings
    """
    res = 0
    for string in text:
        min_ham = np.infty
        for i in range(0, len(string)-len(pattern)+1):
            ham = hamming(pattern, string[i:i+len(pattern)])
            if ham < min_ham:
                min_ham = ham
        res += min_ham

    return res


def compute_prob(pattern: str, profile: np.array):
    """
    Compute probability that profile generates pattern
    """
    res = 1
    letter_indices = {
        "A": 0,
        "C": 1,
        "G": 2,
        "T": 3
    }
    for index, letter in enumerate(pattern):
        res *= profile[letter_indices[letter], index]

    return res


def most_probable(text: str, k: int, profile: np.array):
    """
    Profile-most probable k-mer in Text -- a k-mer that was most likely
    to have been generated by Profile among all k-mers in Text.

    Input: A string Text, an integer k, and a 4 × k matrix Profile.
    Output: A Profile-most probable k-mer in Text.
    """
    highest_prob = 0
    res = text[0:0+k]
    for i in range(0, len(text) - k + 1):
        pattern = text[i:i+k]
        prob = compute_prob(pattern, profile)
        if prob > highest_prob:
            highest_prob = prob
            res = pattern

    return res


def generate_profile(Dna: np.array):
    """
    Generate profile from given sequence of strings
    """
    letter_indices = {
        "A": 0,
        "C": 1,
        "G": 2,
        "T": 3
    }
    res = np.zeros((4, len(Dna[0])))
    for i in range(len(Dna)):
        for j in range(len(Dna[0])):
            res[letter_indices[Dna[i][j]], j] += 1
    res = res + np.ones_like(res)
    return np.divide(res, np.sum(res, axis=0))


def compute_consensus(profile: np.array):
    """
    Compute consensus for given profile
    """
    letter_indices = {
        0: "A",
        1: "C",
        2: "G",
        3: "T"
    }
    return "".join([letter_indices[j] for j in np.argmax(profile, axis=0)])


def gibbs_sampler(Dna: list, k: int, t: int, N: int):
    """
    GibbsSampler(Dna, k, t, N)
        randomly select k-mers Motifs = (Motif1, …, Motift) in each string from Dna
        BestMotifs ← Motifs
        for j ← 1 to N
            i ← Random(t)
            Profile ← profile matrix constructed from all strings in Motifs except for Motifi
            Motifi ← Profile-randomly generated k-mer in the i-th sequence
            if Score(Motifs) < Score(BestMotifs)
                BestMotifs ← Motifs
        return BestMotifs
    """
    Motifs = [None]*t
    for i in range(0, t):
        r = np.random.randint(0, len(Dna[i])-k+1)
        Motifs[i] = Dna[i][r: r+k]
    BestMotifs = Motifs
    profile_best = generate_profile(BestMotifs)
    consensus_best = compute_consensus(profile_best)
    score_best = distance_to_text(consensus_best, BestMotifs)

    for _ in range(N):
        i = np.random.randint(t)
        del Motifs[i]
        profile = generate_profile(Motifs)
        motifi = most_probable(Dna[i], k, profile)
        Motifs.insert(i, motifi)
        consensus = compute_consensus(profile)
        score = distance_to_text(consensus, Motifs)
        if score < score_best:
            BestMotifs = Motifs
            consensus_best = consensus
            score_best = score
            profile_best = profile

    print(score_best)
    return BestMotifs, score_best


if __name__ == '__main__':
    with open("/home/snopoff/Downloads/rosalind_ba2g.txt", "r") as f:
        lines = f.readlines()
    strings = [line.strip() for line in lines]
    k, t, N = list(map(int, strings[0].split(" ")))

    Dna = strings[1:]

    best_res, best_score = "", np.infty
    for _ in range(20):
        res, score = gibbs_sampler(Dna, k, t, N)
        if score < best_score:
            best_res = res
            best_score = score
    print(best_score)
    res = "\n".join(best_res)
    with open(os.getcwd() + "/res.txt", "w") as f:
        f.write("".join(list(map(str, res))))
