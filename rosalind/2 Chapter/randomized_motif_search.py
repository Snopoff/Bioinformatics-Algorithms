"""
#!Implement RandomizedMotifSearch

    * RANDOMIZEDMOTIFSEARCH(Dna, k, t)
    *     randomly select k-mers Motifs = (Motif1, …, Motift) in each string
    *         from Dna
    *     BestMotifs ← Motifs
    *     while forever
    *         Profile ← Profile(Motifs)
    *         Motifs ← Motifs(Profile, Dna)
    *         if Score(Motifs) < Score(BestMotifs)
    *             BestMotifs ← Motifs
    *         else
    *             return BestMotifs

* Given: Positive integers k and t, followed by a collection of strings Dna.
* Return: A collection BestMotifs resulting from running RandomizedMotifSearch(Dna, k, t) 1000 times. 
*         Remember to use pseudocounts!
"""
import numpy as np
import os


def hamming(str1: str, str2: str):
    """
    Hamming Distance Problem: Compute the Hamming distance between two strings.

    Input: Two strings of equal length.
    Output: The Hamming distance between these strings.

    """
    assert len(str1) == len(str2)
    n = len(str1)
    res = 0
    for i in range(0, n):
        res += str1[i] != str2[i]
    return res


def distance_to_text(pattern: str, text: list):
    """
    Computes distance to text, where text is given as a collection of strings
    """
    res = 0
    for string in text:
        min_ham = np.infty
        for i in range(0, len(string)-len(pattern)+1):
            ham = hamming(pattern, string[i:i+len(pattern)])
            if ham < min_ham:
                min_ham = ham
        res += min_ham

    return res


def compute_prob(pattern: str, profile: np.array):
    """
    Compute probability that profile generates pattern
    """
    res = 1
    letter_indices = {
        "A": 0,
        "C": 1,
        "G": 2,
        "T": 3
    }
    for index, letter in enumerate(pattern):
        res *= profile[letter_indices[letter], index]

    return res


def most_probable(text: str, k: int, profile: np.array):
    """
    Profile-most probable k-mer in Text -- a k-mer that was most likely
    to have been generated by Profile among all k-mers in Text.

    Input: A string Text, an integer k, and a 4 × k matrix Profile.
    Output: A Profile-most probable k-mer in Text.
    """
    highest_prob = 0
    res = text[0:0+k]
    for i in range(0, len(text) - k + 1):
        pattern = text[i:i+k]
        prob = compute_prob(pattern, profile)
        if prob > highest_prob:
            highest_prob = prob
            res = pattern

    return res


def generate_profile(Dna: np.array):
    """
    Generate profile from given sequence of strings
    """
    letter_indices = {
        "A": 0,
        "C": 1,
        "G": 2,
        "T": 3
    }
    res = np.zeros((4, len(Dna[0])))
    for i in range(len(Dna)):
        for j in range(len(Dna[0])):
            res[letter_indices[Dna[i][j]], j] += 1
    res = res + np.ones_like(res)
    return np.divide(res, np.sum(res, axis=0))


def compute_consensus(profile: np.array):
    """
    Compute consensus for given profile
    """
    letter_indices = {
        0: "A",
        1: "C",
        2: "G",
        3: "T"
    }
    return "".join([letter_indices[j] for j in np.argmax(profile, axis=0)])


def generate_motifs(profile: np.array, Dna: list):
    """
    Generate new stack of motifs using profile
    """
    Motifs = [None]*len(Dna)
    for i in range(len(Motifs)):
        Motifs[i] = most_probable(Dna[i], profile.shape[1], profile)

    return Motifs


def randomized_motif_search(Dna: list, k: int, t: int):
    """
    RandomizedMotifSearch(Dna, k, t)
        randomly select k-mers Motifs = (Motif1, …, Motift) in each string from Dna
        BestMotifs ← Motifs
        while forever
            Profile ← Profile(Motifs)
            Motifs ← Motifs(Profile, Dna)
            if Score(Motifs) < Score(BestMotifs)
                BestMotifs ← Motifs
            else
                return BestMotifs

    Input: Integers k and t, followed by a space-separated collection of strings Dna.
    Output: A collection BestMotifs resulting from running RandomizedMotifSearch(Dna, k, t) 1,000 times. 
            Remember to use pseudocounts!
    """
    Motifs = [None]*t
    for i in range(0, t):
        r = np.random.randint(0, len(Dna[i])-k+1)
        Motifs[i] = Dna[i][r: r+k]
    BestMotifs = Motifs
    profile_best = generate_profile(BestMotifs)
    consensus_best = compute_consensus(profile_best)
    score_best = distance_to_text(consensus_best, BestMotifs)

    while True:
        profile = generate_profile(Motifs)
        Motifs = generate_motifs(profile, Dna)
        consensus = compute_consensus(profile)
        score = distance_to_text(consensus, Motifs)
        if score < score_best:
            BestMotifs = Motifs
            consensus_best = consensus
            score_best = score
            profile_best = profile
        else:
            print(score_best)
            return BestMotifs

    print(score_best)
    return BestMotifs


if __name__ == '__main__':
    with open("/home/snopoff/Downloads/rosalind_ba2f.txt", "r") as f:
        lines = f.readlines()
    strings = [line.strip() for line in lines]
    k, t = list(map(int, strings[0].split(" ")))

    Dna = strings[1:]

    res = randomized_motif_search(Dna, k, t)
    res = "\n".join(res)
    with open(os.getcwd() + "/res.txt", "w") as f:
        f.write("".join(list(map(str, res))))
