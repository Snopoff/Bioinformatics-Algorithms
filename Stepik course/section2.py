from section1 import neighbors, approx_pattern_matching, hamming
import os
import numpy as np


def motif_enumeration(Dna: list, k: int, d: int):
    """
    MotifEnumeration(Dna, k, d)
        Patterns ← an empty set
        for each k-mer Pattern in Dna
            for each k-mer Pattern’ differing from Pattern by at most d mismatches
                if Pattern' appears in each string from Dna with at most d mismatches
                    add Pattern' to Patterns
        remove duplicates from Patterns
        return Patterns

    Input: Integers k and d, followed by a space-separated collection of strings Dna.
    Output: All (k, d)-motifs in Dna.
    """
    Dna = Dna.split(" ")
    print(Dna)
    patterns = []
    for dna_string in Dna:
        for i in range(0, len(dna_string) - k):
            pattern = dna_string[i:i+k]
            neighborhood = neighbors(pattern, d)
            for neighbor in neighborhood:
                is_in_all_string = True
                for dna in Dna:
                    appearances = approx_pattern_matching(neighbor, dna, d)
                    if not appearances:
                        is_in_all_string = False
                        break
                if is_in_all_string:
                    patterns.append(neighbor)

    patterns = list(set(patterns))
    return patterns


def distance_to_text(pattern: str, text: list):
    """
    Computes distance to text, where text is given as a collection of strings
    """
    res = 0
    for string in text:
        min_ham = np.infty
        for i in range(0, len(string)-len(pattern)+1):
            ham = hamming(pattern, string[i:i+len(pattern)])
            if ham < min_ham:
                min_ham = ham
        res += min_ham

    return res


def median_string(Dna: list, k: int):
    """
    MedianString(Dna, k)
        distance ← ∞
        for each k-mer Pattern from AA…AA to TT…TT
            if distance > d(Pattern, Dna)
                distance ← d(Pattern, Dna)
                Median ← Pattern
        return Median

    Input: An integer k, followed by a space-separated collection of strings Dna.
    Output: A k-mer Pattern that minimizes d(Pattern, Dna) among all possible choices of k-mers.
    """
    dist = np.infty
    median = ''
    all_possible_patterns = neighbors("A"*k, k)
    for pattern in all_possible_patterns:
        dist_to_text = distance_to_text(pattern, Dna)
        if dist_to_text < dist:
            dist = dist_to_text
            median = pattern
    return median


def compute_prob(pattern: str, profile: np.array):
    """
    Compute probability that profile generates pattern
    """
    res = 1
    letter_indices = {
        "A": 0,
        "C": 1,
        "G": 2,
        "T": 3
    }
    for index, letter in enumerate(pattern):
        res *= profile[letter_indices[letter], index]

    return res


def most_probable(text: str, k: int, profile: np.array):
    """
    Profile-most probable k-mer in Text -- a k-mer that was most likely 
    to have been generated by Profile among all k-mers in Text.

    Input: A string Text, an integer k, and a 4 × k matrix Profile.
    Output: A Profile-most probable k-mer in Text.
    """
    highest_prob = 0
    res = ''
    for i in range(0, len(text) - k + 1):
        pattern = text[i:i+k]
        prob = compute_prob(pattern, profile)
        if prob > highest_prob:
            highest_prob = prob
            res = pattern

    return res


def first_task(curr_dir: str):
    """
    Implement MotifEnumeration (reproduced below).

    Input: Integers k and d, followed by a space-separated collection of strings Dna.
    Output: All (k, d)-motifs in Dna.   
    """
    with open("/home/snopoff/Downloads/dataset_240238_8.txt", "r") as f:
        lines = f.readlines()
    str1, str2 = [line.strip() for line in lines]
    k, d = list(map(int, str1.split(" ")))

    res = motif_enumeration(str2, k, d)
    print(len(res))
    with open(curr_dir + "/res.txt", "w") as f:
        f.write(" ".join(list(map(str, res))))


def second_task(curr_dir: str):
    """
    Code Challenge: Implement MedianString.

    Input: An integer k, followed by a space-separated collection of strings Dna.
    Output: A k-mer Pattern that minimizes d(Pattern, Dna) among all possible choices of k-mers. 
            (If there are multiple such strings Pattern, then you may return any one.)
    """
    with open("/home/snopoff/Downloads/dataset_240240_9 (1).txt", "r") as f:
        lines = f.readlines()
    print(lines)
    strings = [line.strip() for line in lines]
    k = int(strings[0])

    text = strings[1:]
    print("\n{}".format(text))

    res = median_string(text, k)
    print(res)
    with open(curr_dir + "/res.txt", "w") as f:
        f.write(res)


def third_task(curr_dir: str):
    """
    Profile-most Probable k-mer Problem: Find a Profile-most probable k-mer in a string.

    Input: A string Text, an integer k, and a 4 × k matrix Profile.
    Output: A Profile-most probable k-mer in Text.
    """
    with open("/home/snopoff/Downloads/dataset_240241_3.txt", "r") as f:
        lines = f.readlines()
    print(lines)
    strings = [line.strip() for line in lines]
    text = strings[0]

    k = int(strings[1])

    profile = np.array([string.split(" ")
                       for string in strings[2:]]).astype('float64')

    res = most_probable(text, k, profile)
    print(res)
    with open(curr_dir + "/res.txt", "w") as f:
        f.write(res)


def second_tests(*args):
    path = "/home/snopoff/Downloads/MedianString/"
    n = len([name for name in os.listdir(path + "inputs")])
    for i in range(2, n+1):
        print("-------")
        print("Stage {}".format(i))
        with open(path + "inputs/input_{}.txt".format(i), "r") as f:
            lines = f.readlines()
        str1, str2 = [line.strip() for line in lines]
        k = int(lines[0].strip())
        text = str2.split(" ")
        print("Input data is:\n k = {}\n text = {}".format(k, text))

        res = median_string(text, k)
        print(res)
        with open(path + "outputs/output_{}.txt".format(i), "r") as f:
            exp = f.read().strip()
        assert res == exp, "In {}:\n res = {}\n exp = {}".format(i, res, exp)


if __name__ == "__main__":
    curr_dir = os.getcwd()
    third_task(curr_dir)
